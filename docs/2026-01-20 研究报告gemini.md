# **基于 Tauri 2.0 的多 AI Chat 聚合桌面客户端：突破 CSP 与 IPC 限制实现本地数据沉淀的深度架构分析报告**

## **1\. 执行摘要与架构背景**

在生成式人工智能（Generative AI）迅速重塑数字交互景观的当下，用户面临着前所未有的“生态系统碎片化”挑战。OpenAI 的 ChatGPT、Anthropic 的 Claude、Google 的 Gemini 以及各类开源模型的托管服务，构建了彼此孤立的“围墙花园”。这种碎片化不仅割裂了用户的工作流，更导致了严重的“数据孤岛”问题——用户的对话历史、思维过程和知识沉淀被锁定在第三方云端，无法进行统一的检索、归档或二次利用。

本报告针对“基于 Tauri 2.0 的多 AI Chat 聚合桌面客户端”这一特定应用场景，进行了详尽的架构可行性分析。该应用的核心价值主张在于“统一入口”与“本地可控的聊天数据沉淀”。所谓“数据沉淀”，不仅是指简单的界面聚合，更要求应用具备从不可信的第三方 Webview 中提取、清洗并持久化存储对话数据的能力。

技术分析表明，虽然 Tauri 2.0 凭借其基于 Rust 的后端和操作系统原生 Webview（Windows 上的 WebView2、macOS 上的 WebKit、Linux 上的 WebKitGTK）提供了远超 Electron 的资源效率（内存占用约为 Electron 的 20% 1），但其严格的“安全优先”设计哲学为数据获取带来了显著的工程障碍。主要瓶颈集中在\*\*内容安全策略（CSP）**的强制执行和**跨进程通信（IPC）\*\*在外部域下的阻断。

本报告提出了一种\*\*“本地优先的中间人（MITM）代理架构”\*\*作为核心解决方案。通过在 Tauri 的 Rust 后端嵌入高性能 HTTP 代理服务器，配合自定义的证书管理和请求拦截逻辑，可以有效剥离第三方服务的 CSP 限制，并建立一条独立于原生 IPC 之外的隐蔽数据传输通道，从而在保障性能的同时实现数据的完全主权。

## **2\. 桌面聚合架构的演进与 Tauri 2.0 的定位**

### **2.1 浏览器视图聚合模式的兴起**

传统的 API 集成模式依赖于供应商提供的结构化接口。然而，在 AI 聚合领域，这种模式存在显著缺陷：API 访问通常需要付费，且往往滞后于 Web 界面所提供的多模态功能（如文件上传、代码执行、画布渲染）。因此，“浏览器视图聚合（BrowserView Aggregation）”成为了一种主流的技术路线。

在这种架构中，桌面客户端充当“超级浏览器（Hyper-Browser）”的角色。它不渲染自身的 UI，而是通过嵌入多个隔离的 Webview 实例来加载 https://chatgpt.com 或 https://claude.ai 等目标网站。客户端的职责从“数据渲染”转变为“容器管理”：负责会话的隔离、窗口的编排以及关键的——DOM 级的仪器化（Instrumentation）。

### **2.2 Tauri 2.0 的核心架构特征**

Tauri 2.0 在架构上与 1.x 版本及 Electron 有着本质区别，这些区别直接影响了聚合客户端的实现路径：

* **原生 Webview 绑定：** Tauri 不像 Electron 那样捆绑 Chromium 内核，而是动态链接系统的 Webview 3。这带来了极小的安装包体积（通常小于 10MB 1）和极低的冷启动时间。  
* **Rust 主进程：** 核心逻辑由 Rust 编写，提供了内存安全和极高的并发处理能力，非常适合处理数据索引和全文检索任务 2。  
* **安全沙箱机制：** Tauri 2.0 强化了权限系统（Capabilities）和插件系统。默认情况下，加载远程 URL（Remote URL）的 Webview 被视为不可信环境，Tauri 会自动剥离 window.\_\_TAURI\_\_ 注入，切断前端与 Rust 后端的直接通信 4。

### **2.3 资源效率的决定性优势**

在多 Agent 并发的场景下，Tauri 的优势被放大。基准测试数据显示，一个空白的 Electron 窗口可能占用 150MB 内存，而 Tauri 的 WebviewWindow 仅占用 30-50MB 2。对于一个需要常驻后台、同时挂载 3-5 个 AI 服务的聚合器而言，Electron 方案的内存基线可能轻易突破 1GB，而 Tauri 方案可控制在 300MB 以内。这种效率差异直接决定了用户是否愿意让该应用“永远在线”。

然而，这种效率的代价是控制力的丧失。Electron 赋予开发者对网络堆栈的绝对控制权（通过 Chrome DevTools Protocol 和 WebRequest API），而 Tauri 则受限于底层系统 Webview 的能力边界。这正是造成 CSP 和 IPC 问题的根源。

## **3\. 核心技术瓶颈深入分析**

在实现“数据沉淀”功能时，开发者面临两个互为因果的技术壁垒：CSP 阻止了脚本的注入与执行，而 IPC 的缺失阻止了数据的回传。

### **3.1 内容安全策略（CSP）：浏览器的免疫系统**

CSP（Content Security Policy）是一种 HTTP 响应头，允许站点管理员声明浏览器被允许加载哪些资源 5。对于 AI 服务提供商而言，CSP 是防御跨站脚本攻击（XSS）的第一道防线，同时也无意中成为了防御“寄生式”聚合应用的铜墙铁壁。

一个典型的 AI 服务 CSP 头部可能包含如下指令：

HTTP

Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.openai.com; connect-src 'self' https://api.openai.com; object-src 'none';

这对聚合客户端造成了毁灭性打击：

1. **脚本注入阻断（Script Injection Blocking）：** 客户端试图通过 webview.eval() 注入的 JavaScript 爬虫脚本，如果包含内联代码（Inline Script）或试图加载外部逻辑，会被浏览器引擎直接拦截，因为它们不在 script-src 的白名单中 7。  
2. **数据外泄阻断（Exfiltration Blocking）：** 即使脚本成功执行并抓取了聊天内容，它需要将数据发送回 Tauri 后端（例如 localhost）。然而，connect-src 'self' 指令严厉禁止 Webview 向除源站以外的任何域（包括本地回环地址）发起 fetch 或 XHR 请求 6。

### **3.2 Tauri 在 CSP 修改上的原生缺陷**

在 Electron 生态中，开发者可以使用 session.webRequest.onHeadersReceived API，在响应头到达渲染进程之前，通过几行 JavaScript 代码将其中的 CSP 字段删除或修改 9。这是 Electron “上帝视角”能力的体现。

相比之下，Tauri 2.0 的网络拦截能力极其有限。根据 Tauri 官方文档及社区反馈 12：

* **on\_web\_resource\_request 的局限：** Tauri 提供了 on\_web\_resource\_request 钩子用于拦截请求。然而，文档明确指出：“目前这仅在针对 tauri URI 协议时执行。**当使用外部 URL（如开发服务器或远程站点）时，此功能目前不会执行**” 12。  
* 这意味着，当 Webview 加载 https://chatgpt.com 时，Rust 后端无法通过标准的 Tauri API 拦截该请求并剔除 CSP 头。  
* **平台差异性：** 虽然在 Windows 平台上可以通过 unsafe 代码将 ICoreWebView2 接口转换为 ICoreWebView2\_2 来监听 WebResourceResponseReceived 事件，但这不仅涉及复杂的 Rust/COM 互操作，且该事件通常只支持“监听”而非“修改” 13。要实现修改，必须取消原请求并完全由 Rust 重新发起（Re-issue），这涉及到极其复杂的 Cookie 和 Session 同步问题。

### **3.3 跨进程通信（IPC）的断裂**

在标准的 Tauri 应用中，前端通过 window.\_\_TAURI\_\_.invoke 调用 Rust 命令。然而，出于安全模型的设计（Capability Security Model），Tauri 2.0 严格禁止在加载远程内容的 Webview 中注入特权 API 4。

* **安全假设：** 远程内容（如 AI 厂商的网页）是不可信的。如果注入了 IPC 桥接，恶意网页可能调用 Rust 文件系统 API 删除用户文件。  
* **结果：** 聚合客户端注入的爬虫脚本处于一个“孤岛”中。它能看到 DOM 结构，能解析出对话文本，但无法将这些文本传递给拥有文件写入权限的 Rust 主进程。

## **4\. 解决方案架构：本地优先的中间人（MITM）代理**

鉴于 Tauri 无法通过原生 API 在渲染层解决 CSP 问题，且无法在远程上下文中直接恢复 IPC，本报告提出一种架构层面的解决方案：**将网络控制权从 Webview 下沉至 Rust 后端**。通过构建一个本地 HTTP 代理服务器，我们可以在流量到达 Webview 之前对其进行任意修改。

### **4.1 架构拓扑设计**

该架构由三个核心组件构成：

1. **Rust 代理服务（The Controller）：** 一个嵌入在 Tauri 主进程中的高性能 HTTP/HTTPS 代理。  
2. **Webview 容器（The View）：** 配置为通过本地代理上网的渲染窗口。  
3. **注入代理（The Agent）：** 运行在 Webview 内部的 JavaScript 脚本，负责 DOM 监听与数据转发。

### **4.2 核心机制一：透明代理与 CSP 剥离**

Rust 生态拥有极强的网络编程能力，利用 hyper、axum 或 reqwest 等库可以轻松构建代理服务。

* **流量接管：** 在创建 WebviewWindow 时，利用 Tauri 2.0 的 proxy\_url 配置项 14，强制该窗口的所有网络请求经过 127.0.0.1:PORT。  
  Rust  
  // Rust 实现示意  
  tauri::WebviewWindowBuilder::new(app, "chat-window", tauri::WebviewUrl::External(target\_url))  
     .proxy\_url(local\_proxy\_url) // 关键配置  
     .build()?;

* **中间人拦截（MITM）：** 由于 AI 服务均使用 HTTPS，Rust 代理必须能够终结 TLS 连接。这意味着应用启动时需要生成一个自签名的根证书（CA），并动态签发针对 chatgpt.com 等域名的伪造证书。  
* **头部清洗：** 代理服务器在收到上游服务器（AI 厂商）的响应后，解析 HTTP 头部，直接删除 Content-Security-Policy、X-Frame-Options 和 Strict-Transport-Security 字段，然后将“净化”后的响应体返回给 Webview。  
* **证书信任问题：** 为了防止 Webview 爆出“证书不可信”的错误，需要在创建窗口时通过 additional\_browser\_args 传入 Chromium/WebKit 标志。例如，在 Windows (WebView2) 上使用 \--ignore-certificate-errors 和 \--test-type 15。虽然这降低了传输层的安全性，但在本地回环环境下是可接受的权衡。

### **4.3 核心机制二：基于 Loopback 的数据逃逸（IPC 替代方案）**

一旦 CSP 被代理服务器剥离（特别是移除了 connect-src 限制），Webview 内部的脚本就获得了向 localhost 发送请求的能力。这为数据传输提供了一条完美的侧信道。

* **数据析出流程：**  
  1. 注入的 JS 脚本（Agent）使用 MutationObserver 监听 DOM 变化，识别新的对话气泡。  
  2. Agent 提取文本内容，构建 JSON 对象。  
  3. Agent 使用标准的 fetch API 向本地代理服务器的特定端点（如 http://127.0.0.1:PORT/bridge/save\_message）发送 POST 请求。  
  4. Rust 代理服务器拦截该特定路径的请求（不向公网转发），解析 JSON 数据。  
  5. Rust 后端将数据写入本地嵌入式数据库（SQLite）。

这种“环回通信（Loopback Communication）”不仅绕过了 Tauri 的 IPC 限制，而且利用了标准的 HTTP 协议，支持大数据量传输，且不依赖任何特定于框架的黑客手段（如标题栏传递数据）。

## **5\. 替代方案的深度对比与淘汰**

在确定 MITM 代理方案之前，我们深入评估了其他几种在 Tauri 社区中讨论的方案，并分析了它们为何不足以支撑企业级的稳定性需求。

### **5.1 方案 A：利用 initialization\_script 与 eval**

Tauri 允许在页面加载前注入初始化脚本 16。

* **局限性：** 仅解决了代码注入问题。如果没有代理服务器剥离 CSP，注入的脚本依然会被浏览器的安全策略锁死，无法执行外联操作。  
* **结论：** 是必要组件，但非独立解决方案。

### **5.2 方案 B：窗口标题（Window Title）侧信道**

这是一种古老的黑客技术。注入的脚本将数据编码后设置为 document.title，Rust 端监听窗口标题变化事件 17 来获取数据。

* **局限性：** 带宽极低（标题长度有限制），且会造成严重的用户体验问题（标题栏闪烁）。在传输长对话或代码块时极不可靠。  
* **结论：** 仅适用于极少量状态同步，不适合数据沉淀。

### **5.3 方案 C：控制台日志（Console Log）拦截**

利用 tauri-plugin-log 或调试协议捕获 Webview 的 console.log 输出 18。

* **机制：** 脚本执行 console.log("DATA::" \+ JSON.stringify(chat))，Rust 端通过正则过滤日志。  
* **优势：** 无需网络代理，实现简单。  
* **缺陷：** 许多生产环境的 Webview 会截断长日志；高频日志可能导致性能抖动；且在某些系统配置下，Webview 的日志通道可能默认关闭。  
* **结论：** 可作为备用方案，但不如 HTTP 环回稳定。

### **5.4 方案 D：剪贴板（Clipboard）中转**

通过 JS 写入剪贴板，Rust 监听剪贴板变化 20。

* **致命缺陷：** 现代浏览器对 navigator.clipboard.writeText 有严格的用户交互要求（User Activation Requirement）22。如果脚本尝试在后台自动写入数据，会被浏览器拒绝。此外，这会破坏用户的正常剪贴板使用体验。  
* **结论：** 不可行。

## **6\. 与 Electron 的多维度对比分析**

为了给决策提供数据支持，我们将 Tauri 2.0（配合代理方案）与 Electron（原生能力方案）进行了详细对比。

| 维度 | Electron (Chromium Bundle) | Tauri 2.0 (Native Webview \+ Rust Proxy) |
| :---- | :---- | :---- |
| **渲染引擎一致性** | **极高**。捆绑特定版本的 Chrome，保证所有用户端的 DOM 结构和 JS 行为一致。 | **低**。依赖用户的系统组件（Edge/Safari/WebKit）。需处理 CSS兼容性问题，DOM 解析器可能需要针对不同引擎微调 3。 |
| **CSP 绕过难度** | **低**。原生 API onHeadersReceived 可直接修改头部 9。代码量 \< 50 行。 | **高**。需实现完整的 HTTP 代理、证书生成、流量转发逻辑。代码量及复杂度显著增加。 |
| **内存占用 (5个实例)** | **极高 (\~1GB+)**。每个 Tab 都是一个完整的 Chrome 进程。 | **低 (\~300MB)**。共享系统动态库，Rust 代理占用极低 1。 |
| **安装包体积** | **大 (\~150MB)**。 | **小 (\<10MB)**。便于分发和更新。 |
| **数据安全性** | **中**。JS 主进程容易受到原型链污染等攻击。 | **高**。Rust 后端提供内存安全，代理层可实施严格的流量清洗规则。 |
| **开发体验 (DX)** | **流畅**。统一的 JS/TS 栈，调试工具完善。 | **割裂**。需同时维护 Rust (后端/网络) 和 JS (前端/注入) 代码。调试 Webview 与 Rust 的交互较为繁琐 25。 |

### **6.1 深度洞察：为何选择 Tauri？**

尽管 Electron 在实现 CSP 绕过上具有“开箱即用”的优势，但对于\*\*“聚合器”\*\*这一特定品类，**内存效率是生死攸关的指标**。用户通常希望聚合器像工具栏一样常驻后台。如果一个聊天工具占用 1.5GB 内存（Electron 的常态），它将被用户频繁关闭，违背了“统一入口”的初衷。Tauri 方案虽然前期开发成本高（需要攻克代理架构），但其交付的最终产品在性能体验上具有压倒性优势。

## **7\. 实施路线图与关键代码逻辑**

基于上述分析，建议采用 **Tauri 2.0 \+ Rust MITM Proxy \+ SQLite** 的技术栈。以下是具体的实施步骤：

### **第一阶段：构建 Rust 代理核心**

在 src-tauri 中引入 reqwest (Client), axum (Server), rcgen (证书生成)。

Rust

// 伪代码：代理处理逻辑  
async fn handle\_request(req: Request\<Body\>) \-\> Response\<Body\> {  
    // 1\. 识别目标 URL  
    let target\_url \= req.headers().get("X-Target-Url").unwrap();  
      
    // 2\. 转发请求 (Rust \-\> AI Provider)  
    let upstream\_res \= client.execute(req).await;  
      
    // 3\. 头部清洗  
    let mut response \= Response::builder();  
    for (key, value) in upstream\_res.headers() {  
        if key\!= "Content-Security-Policy" && key\!= "X-Frame-Options" {  
            response.headers\_mut().insert(key, value);  
        }  
    }  
      
    // 4\. 返回净化后的响应  
    response.body(upstream\_res.bytes().await).unwrap()  
}

### **第二阶段：Webview 配置与证书注入**

利用 additional\_browser\_args 忽略证书错误，配置 proxy\_url 指向本地随机端口。

JSON

// tauri.conf.json  
"windows":

### **第三阶段：注入与沉淀**

编写 injection.js，通过 initialization\_script 注入。

JavaScript

// injection.js  
const observer \= new MutationObserver((mutations) \=\> {  
    mutations.forEach((mutation) \=\> {  
        if (mutation.addedNodes.length) {  
            const newText \= extractText(mutation.target); // 针对特定站点的解析逻辑  
            if (newText) {  
                // 发送给 Rust 代理的特殊路由  
                fetch('http://localhost:port/\_bridge/log', {  
                    method: 'POST',  
                    body: JSON.stringify({ content: newText })  
                });  
            }  
        }  
    });  
});  
observer.observe(document.body, { childList: true, subtree: true });

### **第四阶段：本地存储与检索**

Rust 代理在收到 /\_bridge/log 的请求后，解析数据并调用 rusqlite 将其存入 app\_data\_dir 下的 SQLite 数据库。同时，利用 Rust 的 FTS5 模块构建全文索引，供前端统一搜索界面调用。

## **8\. 结论**

在 Tauri 2.0 框架下开发多 AI 聚合客户端，本质上是一场与现代 Web 安全模型的博弈。原生的 Tauri API 出于安全考量，在设计上并不支持对外部域的侵入式操作，这使得直接的 API 调用在 CSP 和 IPC 问题面前失效。

然而，通过引入**本地中间人代理架构**，我们不仅能够成功绕过 CSP 的限制，还能利用 HTTP 协议构建起稳定、高效的数据回传通道。这一方案虽然增加了架构的初始复杂度，但成功地将 Tauri 的极致性能（低内存、小体积）与 Electron 级别的控制能力结合在一起。

对于追求“本地可控”和“极致性能”的开发者而言，这是一条经过验证且最具可行性的技术路径。它将使得最终产品不仅是一个聚合浏览器，更是一个拥有完整数据主权的个人知识库引擎。

#### **Works cited**

1. Tauri vs Electron Comparison: Choose the Right Framework | by RaftLabs \- Medium, accessed January 16, 2026, [https://raftlabs.medium.com/tauri-vs-electron-a-practical-guide-to-picking-the-right-framework-5df80e360f26](https://raftlabs.medium.com/tauri-vs-electron-a-practical-guide-to-picking-the-right-framework-5df80e360f26)  
2. Tauri vs. Electron: performance, bundle size, and the real trade-offs \- Hopp, accessed January 16, 2026, [https://www.gethopp.app/blog/tauri-vs-electron](https://www.gethopp.app/blog/tauri-vs-electron)  
3. Electron vs. Tauri | DoltHub Blog, accessed January 16, 2026, [https://www.dolthub.com/blog/2025-11-13-electron-vs-tauri/](https://www.dolthub.com/blog/2025-11-13-electron-vs-tauri/)  
4. \[feat\] Inject window.\_\_TAURI\_\_ in allowed remote URLs · Issue ..., accessed January 16, 2026, [https://github.com/tauri-apps/tauri/issues/5088](https://github.com/tauri-apps/tauri/issues/5088)  
5. Content-Security-Policy (CSP) header \- HTTP \- MDN Web Docs, accessed January 16, 2026, [https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy)  
6. Content-Security-Policy (CSP) Header Quick Reference, accessed January 16, 2026, [https://content-security-policy.com/](https://content-security-policy.com/)  
7. Learn & bypass Content Security Policy HTTP Response Header | BrowserStack, accessed January 16, 2026, [https://www.browserstack.com/guide/csp-bypass](https://www.browserstack.com/guide/csp-bypass)  
8. Content Security Policy Bypass Techniques and Security Best Practices \- Vaadata, accessed January 16, 2026, [https://www.vaadata.com/blog/content-security-policy-bypass-techniques-and-security-best-practices/](https://www.vaadata.com/blog/content-security-policy-bypass-techniques-and-security-best-practices/)  
9. webRequest.onHeadersReceived \- Mozilla \- MDN Web Docs, accessed January 16, 2026, [https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest/onHeadersReceived](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest/onHeadersReceived)  
10. Class: WebRequest \- Electron, accessed January 16, 2026, [https://electronjs.org/docs/latest/api/web-request](https://electronjs.org/docs/latest/api/web-request)  
11. Define CSP HTTP Header in Electron App \- javascript \- Stack Overflow, accessed January 16, 2026, [https://stackoverflow.com/questions/51969512/define-csp-http-header-in-electron-app](https://stackoverflow.com/questions/51969512/define-csp-http-header-in-electron-app)  
12. WebviewBuilder in tauri::webview \- Rust \- Docs.rs, accessed January 16, 2026, [https://docs.rs/tauri/latest/tauri/webview/struct.WebviewBuilder.html](https://docs.rs/tauri/latest/tauri/webview/struct.WebviewBuilder.html)  
13. How to modify the headers of a response? · tauri-apps · Discussion ..., accessed January 16, 2026, [https://github.com/tauri-apps/tauri/discussions/6187](https://github.com/tauri-apps/tauri/discussions/6187)  
14. Is there a way to add proxy to Tauri webview? \- Stack Overflow, accessed January 16, 2026, [https://stackoverflow.com/questions/78285683/is-there-a-way-to-add-proxy-to-tauri-webview](https://stackoverflow.com/questions/78285683/is-there-a-way-to-add-proxy-to-tauri-webview)  
15. \[bug\] \`proxy\_url\` not working on Windows when used with \`additional\_browser\_args\` · Issue \#14155 · tauri-apps/tauri \- GitHub, accessed January 16, 2026, [https://github.com/tauri-apps/tauri/issues/14155](https://github.com/tauri-apps/tauri/issues/14155)  
16. \[feat\] Inject javascript from \`on\_window\_ready\` or \`on\_webview\_ready\` (using state data) · Issue \#9099 · tauri-apps/tauri \- GitHub, accessed January 16, 2026, [https://github.com/tauri-apps/tauri/issues/9099](https://github.com/tauri-apps/tauri/issues/9099)  
17. Window in tauri::window \- Rust \- Docs.rs, accessed January 16, 2026, [https://docs.rs/tauri/latest/tauri/window/struct.Window.html](https://docs.rs/tauri/latest/tauri/window/struct.Window.html)  
18. tauri-plugin-debug-tools \- crates.io: Rust Package Registry, accessed January 16, 2026, [https://crates.io/crates/tauri-plugin-debug-tools/0.1.2](https://crates.io/crates/tauri-plugin-debug-tools/0.1.2)  
19. tauri-plugin-log \- crates.io: Rust Package Registry, accessed January 16, 2026, [https://crates.io/crates/tauri-plugin-log](https://crates.io/crates/tauri-plugin-log)  
20. tauri-plugin-clipboard \- crates.io: Rust Package Registry, accessed January 16, 2026, [https://crates.io/crates/tauri-plugin-clipboard](https://crates.io/crates/tauri-plugin-clipboard)  
21. Clipboard \- Tauri, accessed January 16, 2026, [https://v2.tauri.app/plugin/clipboard/](https://v2.tauri.app/plugin/clipboard/)  
22. How do I copy to the clipboard in JavaScript? \- Sentry, accessed January 16, 2026, [https://sentry.io/answers/how-do-i-copy-to-the-clipboard-in-javascript/](https://sentry.io/answers/how-do-i-copy-to-the-clipboard-in-javascript/)  
23. Interact with the clipboard \- Mozilla \- MDN Web Docs, accessed January 16, 2026, [https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact\_with\_the\_clipboard](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard)  
24. Exploring System Webviews in Tauri: Native Rendering for Efficient Cross-Platform Apps, accessed January 16, 2026, [https://dev.to/shrsv/exploring-system-webviews-in-tauri-native-rendering-for-efficient-cross-platform-apps-9hl](https://dev.to/shrsv/exploring-system-webviews-in-tauri-native-rendering-for-efficient-cross-platform-apps-9hl)  
25. Built a desktop app with Tauri 2.0 \- impressions after 6 months : r/rust \- Reddit, accessed January 16, 2026, [https://www.reddit.com/r/rust/comments/1nvvoee/built\_a\_desktop\_app\_with\_tauri\_20\_impressions/](https://www.reddit.com/r/rust/comments/1nvvoee/built_a_desktop_app_with_tauri_20_impressions/)
