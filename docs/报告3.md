# 聊天数据获取与缓存方案研究报告（ChatGPT + Gemini）

日期：2026-01-14

范围：本报告聚焦 ChatGPT 与 Gemini 的聊天数据**自动获取与本地缓存**，遵循当前项目约束（Tauri 2.0、纯本地存储、SQLite、不做加密/云同步）。产品与项目结构、功能清单请参见 `README.md`。

---

## 0. 执行摘要（Executive Summary）

本项目的核心价值在于“统一入口 + 本地可控的聊天数据沉淀”。针对 ChatGPT 与 Gemini 的自动数据获取，现有可选路径主要分为：**子 Webview 注入 + 远程 API 访问**、**iframe + postMessage**、**本地反向代理/内容重写**、**网络层捕获**、**官方导出/增量导入**五类。综合稳定性、维护成本、实现风险与合规边界，本报告建议采用**两段式路线**：

- **短期（MVP+）**：继续保留“子 Webview 注入 + DOM 监听”，但通过能力配置与安全隔离，尽量降低远程 API 访问风险；同时强化“导出/导入”通道作为可靠兜底，并建立“数据质量与去重”策略。
- **中期（稳态化）**：评估并推进“本地反向代理/内容重写”或“网络层捕获”中的**单一高可行路径**，并以最少的 provider 覆盖（仅 ChatGPT+Gemini）验证稳定性；若 iframe 被 CSP/X-Frame-Options 限制，将其定位为**备选/不主路径**。

结论要点：

1. **iframe 方案存在天然阻力**：跨域限制与 X-Frame-Options/CSP frame-ancestors 可能直接阻断嵌入，且无法直接读取 DOM，只能依赖 postMessage（需要注入或代理支持）。
2. **Tauri 远程 API 访问可用但需谨慎**：默认仅允许打包前端访问 Tauri API，远程源需要 capability 放行；并且在某些平台 iframe 与 window 的边界难以区分，存在安全风险。
3. **注入脚本可靠性受平台影响**：Tauri 的 initialization_script 在远程 URL 上不同平台存在执行时机差异，需做好延迟/重试与域名检查。

---

## 1. 背景与目标

### 1.1 目标

- 自动捕获 ChatGPT / Gemini 对话数据
- 本地持久化（SQLite）并可检索
- 不依赖云同步，不做加密
- 可与手动导入/导出共存

### 1.2 成功标准（可量化）

- **捕获完整度**：同一次会话中，消息遗漏率 < 1%
- **延迟**：新消息生成后 3-5 秒内入库
- **稳定性**：连续运行 4 小时无崩溃，切换服务不丢失状态
- **可维护性**：DOM 变化时可通过配置修复（而非改代码）

---

## 2. 约束与风险概览

### 2.1 Tauri 远程 API 限制

- Tauri 默认只允许打包的前端代码访问 API；要允许远程页面调用，需要 capability 显式放行。
- capability 的 Remote API Access 在部分平台（Linux/Android）无法区分 iframe 与 window 的请求，存在边界模糊风险。

### 2.2 跨域与嵌入限制

- **同源策略**限制了跨域页面之间的直接 DOM 访问。
- `window.postMessage` 是跨域安全通信的官方通道，但需要可获得 window 句柄且双方代码配合。
- X-Frame-Options 与 CSP `frame-ancestors` 可以阻止页面被 iframe 嵌入。

### 2.3 初始化脚本执行时机

- Tauri `initialization_script` 在文档解析前注入，但对远程 URL 的执行时机存在平台差异，Android 可能晚于页面脚本。

### 2.4 Mixed Content / 本地服务

- HTTPS 页面请求 HTTP 资源属于 mixed content，浏览器会阻止部分请求；但 loopback（localhost/127.0.0.1）被视为安全来源，细节需验证。

---

## 3. 方案一：子 Webview 注入 + Remote API Access（当前路径升级）

### 3.1 方案概述

- 使用 Tauri `Window.add_child` 创建子 Webview，加载 ChatGPT/Gemini
- 在 `WebviewBuilder.initialization_script` 注入捕获脚本
- MutationObserver 监听 DOM 变化 → 提取消息 → 调用 Tauri 命令写入 SQLite
- 通过 capabilities 放行远程源对特定命令的访问（仅捕获相关 API）

### 3.2 优势

- 与当前架构兼容，改动小
- 无需 iframe，避免被 `X-Frame-Options` / `frame-ancestors` 阻断
- 能直接访问页面 DOM（注入脚本在页面上下文中执行）

### 3.3 风险

- 远程 API Access 安全风险高：一旦放开，远程页面即可调用暴露的命令，需要严格 scope + command 白名单。
- 初始化脚本时机不稳定，尤其在远程 URL 下会出现注入滞后，导致消息捕获不完整。
- DOM 结构变化导致选择器失效，维护成本较高

### 3.4 落地建议

- capability 仅允许 `capture_chat_message`，且域名严格白名单
- 采用「DOM 变化 → 延迟采集」策略，避免流式回复碎片化
- 将 selector 迁移到数据库配置，支持热修复

---

## 4. 方案二：iframe + postMessage（纯前端方案）

### 4.1 方案概述

- 在 React 中使用 `<iframe>` 加载 ChatGPT/Gemini
- 主窗口通过 `postMessage` 与 iframe 通信，获取消息并入库

### 4.2 关键障碍

- **同源策略**禁止父窗口读取跨域 iframe DOM
- 需要目标页面配合或注入脚本才能发送 `postMessage`，否则无法获取内容
- 若页面设置 `X-Frame-Options` 或 CSP `frame-ancestors`，iframe 将直接被阻止

### 4.3 适用场景

- 目标站点允许嵌入，且可注入脚本（或站点本身支持扩展/插件）
- 不适合作为 ChatGPT/Gemini 的主路径（风险过高）

---

## 5. 方案三：本地反向代理 / 内容重写（同源化）

### 5.1 方案概述

- 运行本地代理服务，将远程页面“同源化”
- 重写 HTML，插入采集脚本与 postMessage
- 由本地代理处理资源请求与 API 调用

### 5.2 优势

- 解决跨域与 iframe 限制
- 可在一个统一域名下进行 DOM 采集与 IPC

### 5.3 风险与成本

- 现代站点普遍使用 CSP/SRI/动态脚本，重写极易失效
- WebSocket/Streaming API 需要完整代理支持
- 需要处理证书、HTTPS 与 mixed content 边界
- 维护成本极高，仅适合少量 provider

---

## 6. 方案四：网络层捕获（HTTP/WS 协议解析）

### 6.1 方案概述

- 不解析 DOM，而是捕获网络层 JSON/WS 流
- 从请求响应中还原消息与会话结构

### 6.2 优势

- 结构化数据更稳定，DOM 变更影响小
- 可直接获取 message id / conversation id

### 6.3 风险与成本

- Tauri/Wry 默认不提供完整响应体拦截能力，需要自定义代理或系统级网络代理
- API 频繁变更，协议逆向成本高
- 对 ChatGPT/Gemini 可能需要处理流式数据与压缩协议

---

## 7. 方案五：官方导出 + 增量导入（兜底）

### 7.1 方案概述

- 继续支持官方导出的 JSON（ChatGPT 已支持）
- Gemini 需研究其导出格式

### 7.2 优势

- 合规、稳定、低维护
- 不依赖 DOM/注入

### 7.3 不足

- 非实时，无法即时记录
- 用户依赖手动流程

---

## 8. 方案评估矩阵（ChatGPT + Gemini）

| 方案                           | 稳定性 | 实现成本 | 维护成本 | 安全风险 | 实时性 | 推荐级别 |
| ------------------------------ | ------ | -------- | -------- | -------- | ------ | -------- |
| 子 Webview + 注入 + Remote API | 中     | 中       | 高       | 高       | 高     | ★★★      |
| iframe + postMessage           | 低     | 低       | 中       | 中       | 中     | ★★       |
| 本地反向代理/重写              | 中     | 高       | 很高     | 中       | 高     | ★★       |
| 网络层捕获                     | 高     | 很高     | 高       | 中       | 高     | ★★       |
| 官方导出/导入                  | 高     | 低       | 低       | 低       | 低     | ★★★      |

---

## 9. 推荐路线（分阶段）

### 阶段 1：稳定可用（1-2 周）

- 保持子 Webview 方案，但**严格收敛 capability 白名单**，只允许 `capture_chat_message`
- 建立 selector 配置表（provider 可配置），支持热更新
- 增加消息去重策略：content_hash + (provider_id, session_id)
- 每次捕获写入 raw 日志（便于回放与调试）

### 阶段 2：降风险（2-4 周）

- 研究并实现 Gemini 官方导出导入
- 增加“会话级一致性检查”（对比消息数、时间序）
- 引入“捕获状态可视化”（如当前捕获是否工作、上次更新时间）

### 阶段 3：探索高稳定方案（4-8 周）

- 选择 **网络层捕获** 或 **本地代理** 二选一做 POC
- 仅覆盖 ChatGPT/Gemini，先验证稳定性再推广
- 若 POC 失败，保留 DOM 捕获 + 导出/导入作为稳定组合

---

## 10. 数据模型与缓存策略（基于现有 SQLite）

### 10.1 建议新增字段

- `chat_sessions.provider_conversation_id`（来源 URL 或 API）
- `chat_messages.provider_message_id`（若能获取）
- `chat_messages.version`（支持编辑更新）
- `chat_messages.metadata`（JSON 扩展字段）

### 10.2 去重策略

- `content_hash` 作为主去重键
- 同一 session 内若 hash 相同，跳过写入
- 对流式消息：延迟采集 + 稳定窗口（例如 1-2 秒无变化）

### 10.3 会话识别

- 首选 URL path / conversation id
- 若不可得，按“日期 + service_id”归档

---

## 11. 安全、合规与隐私

- **远程 API Access 需最小授权**：仅开放必要命令，避免远程页面获得过多能力。
- **iframe 风险**：嵌入外部站点可能被 CSP/XFO 阻断，同时存在 clickjacking 风险。
- **跨域通信**：若使用 `postMessage`，必须校验 origin。

---

## 12. 验证与测试策略（思路，不含实现）

- **功能测试**：
  - 捕获一轮 ChatGPT/Gemini 对话，消息数与页面一致
  - 切换服务后继续捕获不丢失
- **回归测试**：
  - DOM selector 变化时应能快速修复
  - 远程 API Access 未授权域名不得调用
- **稳定性测试**：
  - 连续运行 4 小时，无内存暴涨
- **安全测试**：
  - postMessage 必须验证 origin，避免跨站注入

---

## 13. 开放问题

1. 是否允许在 capability 中放行远程源调用命令？接受多大安全风险？
2. 是否接受 DOM 捕获方案带来的维护成本（selector 频繁更新）？
3. 是否愿意投入代理/网络层捕获研发？（周期较长）
4. 是否需要支持会话级编辑（消息更新、删除）？

---

## 参考资料

- Tauri Capabilities / Remote API Access: https://v2.tauri.app/security/capabilities/
- Tauri WebviewBuilder（initialization_script 等）: https://docs.rs/tauri/latest/tauri/webview/struct.WebviewBuilder.html
- MDN X-Frame-Options: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
- MDN CSP frame-ancestors: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors
- MDN Same-origin policy: https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy
- MDN window.postMessage: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
- MDN Mixed content: https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content
